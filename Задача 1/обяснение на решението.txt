# Задача 1

## Въведение в задачата

Задачата има за цел да реализира разпознавател на типовете числови константи в езика C. Това трябва да се осъществи посредством математическия модел на Краен Автомат (Finite State Machine).

Към задачата има текстови файлове, съдържащи много на брой числа, много от които са невалидни. Трябва нашият автомат да върне колко числа от различните типове е преброил.

За решението на задачата Компилатора иска да му предоставиш нарисуван краен автомат, който реално използваш в решението си. В папката аз съм качил снимки на моя и може да се види, че кода ми се гради изцяло около него.
## Етапи на задачата

- Първо от нас се изисква да отворим файла с числата и от него символ по символ да извлечем всички прочетени "думи" (четем докато не стигнем до терминиращ символ като '\n', '\t', шпация / space).
- Една по една подаваме тези "думи" през автоматната функция (те се явяват две - една за целочислените типове и една за реалните / дробните).
- Автоматът обработва "думата" символ по символ като така той сменя различни състояния докато не стигне до конкретния тип числова константа или до грешка.
- Трупа се броят на откритите числа и се извеждат накрая

## Обяснения по алгоритъма ми

По отношение отварянето на файла и четенето на "думите" няма нищо особено като заложена логика. Правя итериране докато не стигна до терминиращ символ и после обработвам това дали изобщо съм открил нещо (ако индекса, който съм достигнал е по-голям от 0). 

От там нататък проверявам дали в "думата" ми се съдържа "." или "E", тъй като това е индикация, че имаме дробно число. Ако числото ни е дробно го изпращаме на автомата за дробни числа, а ако не е дробно при целочисления автомат.

Автоматите ми се изградени спрямо теорията заложена в моделите (отдолу ще оставя полезни линкове). Ако сте запознати на добро ниво с теорията, лесно ще зацепите автоматите ми, няма нещо кой знае колко особено. Нещото което трябва да се има добре предвид е това да обхващаме всеки един възможен случай (в началото изпусках да проверявам дали число е 0).

Като резултат от автомата аз връщам това как да ми се вдигат стойностите на глобалните броячи за всеки един числов тип.

Обработката ми на "думите" се случва докато не достигна до грешка (имам допълнително такова състояние) или докато не стигнем до края "думата" (използвам "word_size + 2" защото след успешно завършване на състояние вдигаме брояча с едно, а реалната големина на "думата" е word_size + 1).

## Особености по решението и предаването на задачата

- Автоматът ВИНАГИ има начално и крайно състояние, не може и не е редно да си сменя състоянията безкрайно.
- Колкото и по-лесно да може задачата да се реши с флагове (булеви стойности) - НЕ Я РЕШАВАЙ ТАКА! Идеята на автоматите е те сами да ти "изплюват" какъв е крайния резултат и да обхожда състояние по състояние, т.е. символ по символ. Автоматът представлява само и единствено switch, който сменя от състояние на състояние и в края връща дадена стойност (нищо повече и нищо по-малко).
- Някои студенти бяха върнати заради това, че са използвали глобални променливи (както аз правя тук). В началото, когато предавахме Задача 1, Веско не гледаше кодовете и моят номер мина, но от там нататък на други хора не им го приемаше по този начин. Ако случайно ти се случи да ти гледа кода - направи така че автомата да не е void, а да връща кодирана стойност (напр. ако автомата ти върне "LONG", през switch пускаш този "LONG" и от там вдигаш броячите - логиката е абсолютно същата, но с малко повече код). 
- Моят автомат не изкарва 100% правилни резултати, поради факта че не проверявам дали всичките "L" при long long числата са еднакво написани (невалидно е да имаме число 12uLl, трябва да е 12uLL или 12ull). Покрай този пропуск задачата ми брои доста повече числа отколкото са реалните, но този резултат е достатъчно добър, че Компилатора да ти напише тройка или четворка. Ако ти се занимава да направиш автомата 100% корекрен, трябва да добавиш тези състояния за еднаква големина на повтарящите се букви.
- НЕ ПРАВИ ЗАДАЧАТА С CHATGPT! ChatGPT не прави задачата както е по условие. За него няма смисъл нещата да се правят по този начин и си използва лесните варианти с флагове и "поточни" логики, които спестяват пространство, НО не решават задачата. Ако Компилатора те хване с такъв код - тежко ти горко... Той ненавижда това да използваме изкуствен интелект и да не можем да обясним какво сме направили чрез него. Това, което AI прави като решение не е правилното за тази задача. Много студенти бяха върнати и после се гледаха по различен начин от Веско, след като той разбра, че те са се опитали да го измамят... Внимавай!
- Кодът изглежда дълъг и стряскащ, но на практика не е. Много от нещата се повтарят и са еднотипни.
- Има шанс Компилатора да ви направи проблем ако сте hardcode-нали (като мен) текстовите файлове да се отварят от сорс кода, а не от терминала. За повече сигурност използвайте "args" в int main().

## Полезни линкове

https://youtu.be/4rNYAvsSkwk?si=_u5vm13YFum4UR7o (Видеоклип, в който съвсем елементарно и базово се обяснява какво е краен автомат)

https://www.youtube.com/watch?v=hJIST1cEf6A (Пример за краен автомат, който реализира светофар. Не е нужно чак толкова подробно и аналитично да се проектира автомата за числа)

https://www.youtube.com/watch?v=Qa6csfkK7_I (По-подробен и математически обяснен видеоклип за крайните автомати)

https://youtu.be/d-5dpjJxQBU (Видеоклип за краен автомат, който реализира логика на подобна задача. Ако схванеш това ще можеш да си решиш задачата без проблеми)