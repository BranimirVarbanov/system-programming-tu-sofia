# Задача 3

## Въведение в задачата

Задачата има за цел да реализира конзолен калкулатор за BCD числа. Като операции трябва да можем да извършваме събиране, 
изваждане, умножение и сравнение. Всичко трябва да се случва изцяло базирано на BCD логиката (не трябва да използваме 
двоични и/или типични integer способи). Идейно задачата представлява това да изградим подобие на хардуер, който софтуерно
да осъществява low-level операциите на BCD калкулатора (трябва да работим bitwise).
"
Изисква се напълно да се изолираме от представата за "+", "-" и "*". Трябва всичко да ни се извършва посредством побитови
(bitwise) операции, т.е. "И" (&), "ИЛИ" (|), "NOT" (~) и т.н.

Числата за събиране не трябва да бъдат повече от 8-цифрени, а тези за събиране не могат да бъдат повече от 4-цифрени.

## Етапи на задачата

- Като за начало от нас се изисква да въведем десетично число, след което то се трансформира в BCD еквивалента си
- Когато вече числото е приведено в BCD формата си, от там нататък то е готово за обработка (задължително е да се
обработва като BCD, не може да се използват "десетични" способи)
- На база подадената от менюто опция се извършва конкретна обработка и резултата се представя в BCD, HEX и двоичния
(binary) си еквивалент

## Особености на задачата

- Както отрицателните числа в двоичен вид се представят чрез техния допълнителен код (two's complement), така и аналогично
отрицателните BCD числа трябва да се представят в техния 10's complement
- Компилатора държи задачата да бъде решена така, сякаш е свързана с предаване на интернет пакети. Това ще рече, че трябва
да има индикация кога число е отрицателно, а не просто едно огромно положително. За тази цел най-старшите битове трябва
да се кодират по различен начин - да не отговарят на число от 0 (0000) до 9 (1001), а някое различно (по-голямо). Аз 
например за такава кодировка използвам направо 1111
- Тъй като Компилатора силно държи на това задачата да бъде подобие на хардуер, събирането и изваждането няма как да се
извършват по типичния десетичен начин (независимо дали е с "+" или bitwise еквивалент на "+"). За решение той ни предложи
да използваме т.нар. look-up tables (LUT's). Те общо взето представляват автоматизирано решение на "допълване до 6" и 
"допълване до 9" (виж теоретичната постановка)
- Умножението може да се извършва по различни начини, моят не е като този по условие на Компилатора, но работи изцяло
в BCD концепцията
- Макар и по условие да е дадено, че числата могат да са максимум 8-цифрени - НЕ ИЗПОЛЗВАЙ 32-битови данни. Когато число
се преобразува в BCD, то за всяка своя цифра се резервират 4 бита. Това ще рече, че 32 бита ще ти стигнат точно за
8-цифрено число, НО сметките могат да бъдат и 9-цифрени (например ако събереш 99 999 999 със себе си резултата вече не е
8-цифрен, а 9-цифрен). Същото важи и когато умножаваш 4-цифрено с 4-цифрено - може да се получи максимум  9-цифрен
резултат. Изполвай 64-битови числови данни

## Обяснение по алгоритъма ми

*утре довършвам*


